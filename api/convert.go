package handler

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"reflect"
	"strings"
	"text/template"
	"unicode"

	"github.com/emicklei/proto"
	"gitter.top/common/goref"
	"gitter.top/common/protofmt"
	"golang.org/x/text/cases"
	"golang.org/x/text/language"
)

func GoType2ProtoType(to reflect.Kind) string {
	switch to {
	case reflect.Int8, reflect.Int16, reflect.Int32:
		return "sint32"
	case reflect.Int, reflect.Int64:
		return "sint64"
	case reflect.Uint8, reflect.Uint16, reflect.Uint32:
		return "fixed32"
	case reflect.Uint, reflect.Uint64:
		return "fixed64"
	case reflect.Bool:
		return "bool"
	case reflect.String:
		return "string"
	case reflect.Float32:
		return "float"
	case reflect.Float64:
		return "double"
	default:
		panic("invalid type: " + to.String())
	}
}

func UnderscoreToUpperCamelCase(s string) string {
	s = strings.Replace(s, "_", " ", -1)
	s = cases.Title(language.English).String(s)
	return strings.Replace(s, " ", "", -1)
}

const (
	// FileHeaderTemplate protobuf file header
	FileHeaderTemplate = `syntax = "proto3";

package your.project.v1;

option go_package = "your/project;projectv1";
`
	// TiledTemplate tiled style message, default style
	TiledTemplate = `{{range $name, $message := .SubMessage}}message {{$name}} {
{{range $idx, $field := $message.Fields}}{{if $field.Repeated}}repeated {{end}} {{$field.Type}} {{$field.Name}} = {{add $idx 1}};
{{end}}
}
{{end}}
message AutoGenerated {
{{range $idx, $field := .Fields}}{{if $field.Repeated}}repeated {{end}} {{$field.Type}} {{$field.Name}} = {{add $idx 1}};
{{end}}
}`
	// EmbedTemplate embed style message
	EmbedTemplate = `message AutoGenerated {
	{{range $name, $message := .SubMessage}}message {{$name}} {
{{range $idx, $field := $message.Fields}}{{if $field.Repeated}}repeated {{end}} {{$field.Type}} {{$field.Name}} = {{add $idx 1}};
{{end}}
}
{{end}}
{{range $idx, $field := .Fields}}{{if $field.Repeated}}repeated {{end}} {{$field.Type}} {{$field.Name}} = {{add $idx 1}};
{{end}}
}`
)

func Add(x, y int) int {
	return x + y
}

func (p *Parser) ProtobufTemplateRender(tpl string) (io.ReadWriter, error) {
	if p.FileHeaderDefinition {
		tpl = FileHeaderTemplate + tpl
	}
	tmpl, err := template.New("file_template").Funcs(template.FuncMap{"add": Add}).Parse(tpl)
	if err != nil {
		return nil, err
	}
	if err := p.tiled(p._rawMessage.SubMessage); err != nil {
		return nil, err
	}
	p._tiledMessage.Fields = p._rawMessage.Fields
	// validate message
	if err := p.validName(p._tiledMessage); err != nil {
		return nil, err
	}
	var buffer = new(bytes.Buffer)
	err = tmpl.Execute(buffer, p._tiledMessage)
	if err != nil {
		return nil, err
	}
	return buffer, nil
}

func (p *Parser) validName(raw *Message) error {
	for _, field := range raw.Fields {
		if !validFieldName(field.Name) {
			return fmt.Errorf("invalid field name '%s'", field.Name)
		}
	}

	for mName, message := range raw.SubMessage {
		if !validFieldName(mName) {
			return fmt.Errorf("invalid message name '%s'", mName)
		}

		for _, field := range message.Fields {
			if !validFieldName(field.Name) {
				return fmt.Errorf("invalid field name '%s.%s'", mName, field.Name)
			}
		}
	}

	return nil
}

type Parser struct {
	FileHeaderDefinition bool                   // output protobuf header, default true
	TiledDefinition      bool                   // output tiled style message, embedded substructure will be displayed in the top-level structure, default true
	MergeMessage         bool                   // merge the same name message, default true
	_data                map[string]interface{} // raw json data
	_rawMessage          *Message               // json data to message
	_tiledMessage        *Message               // merged message
}

type Message struct {
	SubMessage map[string]*Message `json:"sub_message,omitempty"`
	Fields     []*Field            `json:"fields,omitempty"`
}

type Field struct {
	Repeated bool   `json:"repeated,omitempty"`
	Type     string `json:"type,omitempty"`
	Name     string `json:"name,omitempty"`
}

type Option func(parser *Parser)

func WithTiledMessage(isTiled bool) func(parser *Parser) {
	return func(parser *Parser) {
		parser.TiledDefinition = isTiled
	}
}

func WithMergeMessage(isMerge bool) func(parser *Parser) {
	return func(parser *Parser) {
		parser.MergeMessage = isMerge
	}
}

func WithShowFileHeader(isShow bool) func(parser *Parser) {
	return func(parser *Parser) {
		parser.FileHeaderDefinition = isShow
	}
}

func NewParser(r io.Reader, options ...Option) (*Parser, error) {
	buf, err := io.ReadAll(r)
	if err != nil {
		return nil, err
	}
	if !json.Valid(buf) {
		return nil, fmt.Errorf("verify json format failed")
	}
	parser := &Parser{
		_data:         make(map[string]interface{}),
		_rawMessage:   &Message{SubMessage: make(map[string]*Message)},
		_tiledMessage: &Message{SubMessage: make(map[string]*Message)},
	}
	for _, option := range options {
		option(parser)
	}

	if err := json.Unmarshal(buf, &parser._data); err != nil {
		return nil, err
	}
	return parser, nil
}

func (p *Parser) Parse() error {
	p.parse(p._data)
	return nil
}

func (p *Parser) rangeItem(mapIter *reflect.MapIter) *Message {
	if mapIter == nil {
		return nil
	}
	var msg = &Message{SubMessage: make(map[string]*Message)}
	for mapIter.Next() {
		var fd = new(Field)
		fd.Name = mapIter.Key().String()

		value := mapIter.Value()
		if value.Kind() == reflect.Ptr {
			value = value.Elem()
		}
		if value.Kind() == reflect.Interface {
			value = reflect.ValueOf(value.Interface())
		}
		switch value.Kind() {
		case reflect.String, reflect.Bool, reflect.Float32, reflect.Float64:
			fd.Type = GoType2ProtoType(value.Kind())
		case reflect.Map:
			fd.Type = UnderscoreToUpperCamelCase(fd.Name)
			m := p.rangeItem(value.MapRange())
			msg.SubMessage[fd.Type] = m
		case reflect.Slice, reflect.Array:
			fd.Repeated = true
			size := value.Len()
			if size == 0 {
				fd.Type = "google.protobuf.Any"
			} else {
				vi := value.Index(0).Interface()
				if goref.IsBasicType(vi) {
					fd.Type = GoType2ProtoType(reflect.ValueOf(vi).Type().Kind())
				} else {
					fd.Type = UnderscoreToUpperCamelCase(fd.Name)
					m := p.rangeItem(reflect.ValueOf(vi).MapRange())
					msg.SubMessage[fd.Type] = m
				}
			}
		case reflect.Invalid:
			fd.Type = "google.protobuf.Any"
		default:
			fmt.Printf("key: %s, type: %s, value: %v\n", fd.Name, value.Kind().String(), mapIter.Value())
		}
		msg.Fields = append(msg.Fields, fd)
	}
	return msg
}

func (p *Parser) parse(valueOf interface{}) *Message {
	vo := reflect.ValueOf(valueOf)
	if vo.IsZero() {
		return nil
	}
	if vo.Kind() == reflect.Ptr {
		vo = vo.Elem()
	}
	if vo.Kind() == reflect.Map {
		p._rawMessage = p.rangeItem(vo.MapRange())
	}
	return nil
}

// Export get json body to message object
func (p *Parser) Export() *Message {
	return p._rawMessage
}

func (p *Parser) format(buf io.ReadWriter) string {
	pp := proto.NewParser(buf)
	parse, err := pp.Parse()
	if err != nil {
		return err.Error()
	}
	protofmt.NewFormatter(buf, "    ").Format(parse)
	var buffer bytes.Buffer
	_, _ = buffer.ReadFrom(buf)
	return buffer.String()
}

// Output output result
func (p *Parser) Output() string {
	var tpl = EmbedTemplate
	if p.TiledDefinition {
		tpl = TiledTemplate
	}
	writer, err := p.ProtobufTemplateRender(tpl)
	if err != nil {
		return err.Error()
	}
	return p.format(writer)
}

func (p *Parser) merge(a, b *Message) ([]*Field, error) {
	var fieldMap = make(map[string]*Field)
	for _, field := range a.Fields {
		fieldMap[field.Name] = field
	}
	for _, field := range b.Fields {
		old, exist := fieldMap[field.Name]
		if !exist {
			fieldMap[field.Name] = field
			continue
		}
		if field.Repeated != old.Repeated {
			return nil, fmt.Errorf("conflect field %s on repeated attribute", old.Name)
		}
		if field.Type != old.Type {
			return nil, fmt.Errorf("conflect field %s on type attribute", old.Type)
		}
	}
	var newFields []*Field
	for _, field := range fieldMap {
		newFields = append(newFields, field)
	}
	return newFields, nil
}

func (p *Parser) tiled(messages map[string]*Message) error {
	if len(messages) == 0 {
		return nil
	}
	for name, message := range messages {
		if err := p.tiled(message.SubMessage); err != nil {
			return err
		}
		old, exist := p._tiledMessage.SubMessage[name]
		if !exist {
			p._tiledMessage.SubMessage[name] = message
			continue
		}
		mergeFields, err := p.merge(message, old)
		if err != nil {
			return err
		}
		p._tiledMessage.SubMessage[name].Fields = mergeFields
	}
	return nil
}

func Handler(w http.ResponseWriter, r *http.Request) {
	body, err := io.ReadAll(r.Body)

	if err != nil {
		responseFailed(w, err)
		return
	}

	reader := bytes.NewReader(body)

	parser, err := NewParser(reader, WithShowFileHeader(true), WithMergeMessage(true), WithTiledMessage(false))
	if err != nil {
		responseFailed(w, err)
		return
	}
	err = parser.Parse()
	if err != nil {
		responseFailed(w, err)
		return
	}
	responseOK(w, parser.Output())
}

func responseOK(w http.ResponseWriter, output string) {
	w.WriteHeader(http.StatusOK)
	w.Header().Set("Content-Type", "text/plain")
	_, _ = w.Write([]byte(output))
}

func responseFailed(w http.ResponseWriter, err error) {
	w.WriteHeader(http.StatusBadRequest)
	w.Header().Set("Content-Type", "text/plain")
	_, _ = w.Write([]byte("bad request: " + err.Error()))
}

func validFieldName(field string) bool {
	if len(field) == 0 {
		return false
	}
	firstChar := rune(field[0])
	if !unicode.IsLetter(firstChar) && firstChar != '_' {
		return false
	}
	for _, char := range field[1:] {
		if !unicode.IsLetter(char) && !unicode.IsNumber(char) && char != '_' {
			return false
		}
	}
	return true
}
